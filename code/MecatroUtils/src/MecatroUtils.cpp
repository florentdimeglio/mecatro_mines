// Motor PWM pin direction
#define DIRECTION_MOTOR_RIGHT 12
#define DIRECTION_MOTOR_LEFT 8

#include <Arduino.h>
#include "Arduino_LED_Matrix.h"
#include "Wire.h"
#include "WiFiS3.h"

#include "MecatroUtils.h"
#include "Telemetry.h"

unsigned long tickTime;

// Forward interrupt call to user function.
bool shouldRun = false;
unsigned int nIter = 0;
unsigned int targetIter = 0;
uint8_t eventLinkIndex;
void timerOverflowCallback()
{
    // Reset the interrupt link and the flag for the timer
    R_ICU->IELSR[eventLinkIndex] &= ~(R_ICU_IELSR_IR_Msk);
    R_GPT7->GTST &= ~(R_GPT0_GTST_TCFPO_Msk);

    nIter ++;
    if (nIter == targetIter)
    {
        shouldRun = true;
        nIter = 0;
    }
}

namespace mecatro{
    void configureArduino(unsigned char const controlPeriodMs)
    {
        // Stop interrupts while configuring registers.
        __disable_irq();

        // Configure direction pins as output
        pinMode(DIRECTION_MOTOR_RIGHT, OUTPUT);
        pinMode(DIRECTION_MOTOR_LEFT, OUTPUT);

        // Motor signal generation: we need configure the Arduino to generate a high-frequency signal
        // (typically 5-20kHz).
        // This is done using hardware PWM, i.e. the signal is generated by a timer physically present
        // in the microcontroller, not software running inside the CPU. This allows fast and accurate signal
        // generation, and takes absolutely no processing power.
        // Such timers exist on all microcontrollers, but each family has a difference interface.
        // The Arduino R4 uses a RA4M1, which describes its timers in Chapter 22 of the documentation.
        // Specifically, we use GPT167 maped to pin 9 (port B) and GPT162 to pin 10 (port A) , in saw-wave PWM mode.

        // First we enable the timers, and unlock the PWM registers
        R_MSTP->MSTPCRD &= ~(1 << R_MSTP_MSTPCRD_MSTPD6_Pos);
        R_GPT7->GTWP = 0xA500;


        // Now we configure the PWM, according to FIgure 22.30.
        R_GPT7->GTCR = 0; // Saw-wave PWM, no prescaller
        R_GPT7->GTUDDTYC = 0b01; // Up-counting
        R_GPT7->GTPR = 2399; // 20kHz frequency (MCU at 48MHz)
        R_GPT7->GTCNT = 0; // Reset counter
        R_GPT7->GTIOR = 0b100011001 << 16; // Signal form: high before compare match.
        R_GPT7->GTCCR[1] = 0; // Make sure the motor starts off

        R_GPT2->GTCR = 0; // Saw-wave PWM, no prescaller
        R_GPT2->GTUDDTYC = 0b01; // Up-counting
        R_GPT2->GTPR = 2399; // 20kHz frequency (MCU at 48MHz)
        R_GPT2->GTCNT = 0; // Reset counter
        R_GPT2->GTIOR = 0b100011001; // Signal form: high before compare match.
        R_GPT2->GTCCR[0] = 0; // Make sure the motor starts off


        // Finally we set these pins to the corresponding function
        R_PFS->PORT[3].PIN[3].PmnPFS = (1 << R_PFS_PORT_PIN_PmnPFS_PDR_Pos) | (1 << R_PFS_PORT_PIN_PmnPFS_PMR_Pos) | (3 << R_PFS_PORT_PIN_PmnPFS_PSEL_Pos);
        R_PFS->PORT[1].PIN[3].PmnPFS = (1 << R_PFS_PORT_PIN_PmnPFS_PDR_Pos) | (1 << R_PFS_PORT_PIN_PmnPFS_PMR_Pos) | (3 << R_PFS_PORT_PIN_PmnPFS_PSEL_Pos);

        // And start the timers
        R_GPT2->GTCR |= 1;
        R_GPT7->GTCR |= 1;

        // Now we an interrupt callback on timer 7 overflow. This generates a 10kHz callback which we use for control
        // loop. Note that one could easily use another timer to decorrelate this frequency from that of the motor
        // driver, for as long as we are only interested in multiples of 100us I saw no need for that.


        timer_cfg_t base;
        base.channel = 7;
        base.cycle_end_irq = FSP_INVALID_VECTOR;
        TimerIrqCfg_t iCfg;
        iCfg.base_cfg = &base;
        gpt_extended_cfg_t fake;
        iCfg.gpt_ext_cfg = &fake;

        if (IRQManager::getInstance().addTimerOverflow(iCfg, timerOverflowCallback))
        {
            eventLinkIndex = iCfg.base_cfg->cycle_end_irq;
            R_BSP_IrqDisable((IRQn_Type)eventLinkIndex);
            R_BSP_IrqStatusClear((IRQn_Type)eventLinkIndex);
            NVIC_SetPriority((IRQn_Type)eventLinkIndex, 14);
            R_BSP_IrqEnable((IRQn_Type)eventLinkIndex);
        }

        // Timer interrupt
        targetIter = 20 * controlPeriodMs;

        __enable_irq();

        // I2C configuration
        // Set I2C clock speed to 400kHz (fast mode)
        // Note: this has to be done after starting the encoder, because their code reset the clock to 100kHz.
        Wire.setClock(400000);
        // Set I2C master timeout to 500us - this line is very important, otherwise the Arduino can enter into an endless loop
        // when trying - and failing - to talk to the IMU.
        Wire.setTimeout(500);
    }

    void setMotorDutyCycle(float const& leftMotorDC, float const& rightMotorDC)
    {
        // Set direction
        digitalWrite(DIRECTION_MOTOR_RIGHT, rightMotorDC > 0);
        digitalWrite(DIRECTION_MOTOR_LEFT, leftMotorDC > 0);
        // Set duty cycle: the timer counts up to R_GPT2->GTPR.
        int counterValue = floor(abs(rightMotorDC) * R_GPT2->GTPR);
        if (counterValue > R_GPT2->GTPR)
          counterValue = R_GPT2->GTPR;
        R_GPT2->GTCCR[0] = counterValue;

        counterValue = floor(abs(leftMotorDC) * R_GPT7->GTPR);
        if (counterValue > R_GPT7->GTPR)
          counterValue = R_GPT7->GTPR;
        R_GPT7->GTCCR[1]  = counterValue;
    }

    void run()
    {
      while (true)
      {
        // Wait for tick from interrupt
        while (!shouldRun)
          __asm__("nop\n\t");
        // Configure telemetry
        tickTime = micros();
        shouldRun = false;
        // Run control loop iteself
        mecatro::controlLoop();
        // Handle telemetry
        if (nTelemetryVariables > 0)
          sendTelemetry();
      }
    }
};
